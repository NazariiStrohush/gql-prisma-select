name: Auto Release

on:
  push:
    branches: [master, main]
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  auto-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    # Only run on push to main/master (not PRs) or manual dispatch
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'))

    steps:
      # Build and Test Phase
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch all tags
        run: git fetch --tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
          scope: '@nazariistrohush'

      - name: Install dependencies
        run: npm ci

      - name: Run build
        run: npm run build

      - name: Run tests
        run: npm test

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Get latest tag
        id: get_tag
        run: |
          # Get all semantic version tags (with or without v prefix), sort by version
          LATEST_TAG=$(git tag -l | grep -E "^[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -1)
          PKG_VERSION="${{ steps.current_version.outputs.version }}"

          if [ -z "$LATEST_TAG" ]; then
            echo "No existing semantic version tags found, using package.json version as base"
            LATEST_VERSION="$PKG_VERSION"
          else
            LATEST_VERSION="$LATEST_TAG"
            echo "Latest version tag: $LATEST_TAG (version: $LATEST_VERSION)"
            echo "Package.json version: $PKG_VERSION"
          fi

          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "Base version for increment: $LATEST_VERSION"

      - name: Determine version bump type
        id: bump_type
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            BUMP_TYPE="${{ github.event.inputs.version_bump }}"
          else
            # Default to patch for automatic releases
            BUMP_TYPE="patch"
          fi
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Version bump type: $BUMP_TYPE"

      - name: Calculate next version
        id: next_version
        run: |
          CURRENT="${{ steps.get_tag.outputs.latest_version }}"
          BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
          PKG_VERSION="${{ steps.current_version.outputs.version }}"

          echo "Current tag: $CURRENT"
          echo "Package version: $PKG_VERSION"
          
          # If package.json version is strictly greater than current tag, use it directly.
          # Otherwise, apply the requested bump to the package.json version.
          
          # Function to compare versions
          # Returns 1 if $1 > $2, 2 if $1 < $2, 0 if equal
          vercomp () {
              if [[ $1 == $2 ]]; then return 0; fi
              local IFS=.
              local i ver1=($1) ver2=($2)
              # fill empty fields in ver1 with zeros
              for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do ver1[i]=0; done
              for ((i=0; i<${#ver1[@]}; i++)); do
                  if [[ -z ${ver2[i]} ]]; then ver2[i]=0; fi
                  if ((10#${ver1[i]} > 10#${ver2[i]})); then return 1; fi
                  if ((10#${ver1[i]} < 10#${ver2[i]})); then return 2; fi
              done
              return 0
          }
          
          vercomp "$PKG_VERSION" "$CURRENT"
          RESULT=$?
          
          # If package.json > tag, use package.json version as BASE
          if [ $RESULT -eq 1 ]; then
             echo "Package.json version ($PKG_VERSION) is higher than latest tag ($CURRENT). Using package.json version as base."
             BASE_VERSION="$PKG_VERSION"
             # If it's a manual workflow dispatch, we MIGHT still want to bump this base if intended
             # But typically if I set 1.0.0 in package.json manually, I want 1.0.0.
             # So if manual change is detected (PKG > TAG), we assume that IS the target version unless specifically bumped again?
             # Actually, the user request is: "get current version from package.json and bump related to requested level"
             # So if package.json is 1.0.0 and I request 'patch', it should become 1.0.1
             # If package.json is 1.0.0 and I just pushed (default patch), it should become 1.0.1?
             # WAIT. If I manually set 1.0.0, I probably want to release 1.0.0.
             # BUT the prompt says "bump related to requested level".
             # Let's interpret "bump related to requested level" as: Always take package.json version as the source of truth,
             # and apply the bump to THAT.
             
             # However, if I just manually edited package.json to 1.0.0, and I push, the "bump type" defaults to patch.
             # So it would become 1.0.1. This might NOT be what is wanted if I explicitly set 1.0.0.
             # Usually if package.json is manually changed, that IS the release version.
             
             # Let's look at the error: "version bumped to 0.2.0 instead of next from 1.0.0"
             # This means it ignored 1.0.0 and bumped 0.1.x to 0.2.0.
             
             # If I set 1.0.0, I want 1.0.0 to be released.
             # UNLESS I am running a workflow_dispatch to say "bump minor", then I want 1.1.0?
             # Let's stick to standard behavior:
             # 1. If package.json version > latest tag, USE package.json version exactly (assume manual bump).
             # 2. If package.json version <= latest tag, calculate next version from TAG + bump type.
             
             NEXT_VERSION="$PKG_VERSION"
             echo "Using manual version from package.json: $NEXT_VERSION"

          else
             # Package.json is old or same as tag. Calculate next version from TAG.
             # But wait, the user asked: "change flow to get current version from package,json and bump related to requested level"
             # This implies ignoring tags for the calculation base?
             # If I have 0.1.7 in tag, and 0.1.7 in package.json. Bump patch -> 0.1.8.
             # If I have 0.1.7 in tag, and 1.0.0 in package.json. Bump patch -> 1.0.1? Or 1.0.0?
             
             # If I assume the user WANTS the bump logic to always run on top of package.json:
             # Then 1.0.0 + patch = 1.0.1.
             # But if they manually set 1.0.0, they probably wanted 1.0.0.
             
             # The error "version bumped to 0.2.0 instead of next from 1.0.0" suggests they expected 1.0.0 (or something derived from it).
             # My previous fix (which tried to use PKG_VERSION if > CURRENT) failed because of shell script syntax error likely? 
             # "Error: Process completed with exit code 1." often comes from syntax errors.
             # The syntax error was likely `if [ $RESULT -eq 1 ]; then` if vercomp didn't return properly or something.
             
             # Let's implement this logic:
             # BASE = package.json version.
             # IF manual dispatch event: apply bump to BASE.
             # IF push event:
             #   IF package.json > latest tag: use package.json version AS IS (manual bump).
             #   ELSE: apply default patch bump to latest tag (automatic bump).
             
             if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
                # Explicit bump requested. Apply to package.json version.
                BASE_VERSION="$PKG_VERSION"
                SHOULD_BUMP=true
             else
                # Automatic push
                if [ $RESULT -eq 1 ]; then
                   # Package.json manually updated to be higher. Use it as is.
                   NEXT_VERSION="$PKG_VERSION"
                   SHOULD_BUMP=false
                   echo "Manual version update detected in package.json. Releasing $NEXT_VERSION"
                else
                   # Package.json not updated manually. Bump the TAG.
                   BASE_VERSION="$CURRENT"
                   SHOULD_BUMP=true
                fi
             fi
             
             if [ "$SHOULD_BUMP" = true ]; then
                IFS='.' read -ra VERSION_PARTS <<< "$BASE_VERSION"
                MAJOR=${VERSION_PARTS[0]}
                MINOR=${VERSION_PARTS[1]}
                PATCH=${VERSION_PARTS[2]}

                case "$BUMP_TYPE" in
                  major)
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                    ;;
                  minor)
                    MINOR=$((MINOR + 1))
                    PATCH=0
                    ;;
                  patch)
                    PATCH=$((PATCH + 1))
                    ;;
                esac
                NEXT_VERSION="$MAJOR.$MINOR.$PATCH"
             fi
          fi

          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEXT_VERSION"

      # Release Decision Phase
      - name: Check if tag already exists
        id: check_tag
        run: |
          NEXT_VERSION="${{ steps.next_version.outputs.next_version }}"
          if git tag -l | grep -q "^${NEXT_VERSION}$"; then
            echo "Tag $NEXT_VERSION already exists, skipping release"
            echo "should_release=false" >> $GITHUB_OUTPUT
          else
            # Check if commit message contains [skip release]
            if echo "${{ github.event.head_commit.message }}" | grep -qi "\[skip release\]"; then
              echo "Release skipped by commit message"
              echo "should_release=false" >> $GITHUB_OUTPUT
            elif echo "${{ github.event.head_commit.message }}" | grep -qi "update\|dependency\|package"; then
              echo "Dependency/package update detected, skipping automatic release"
              echo "should_release=false" >> $GITHUB_OUTPUT
            else
              echo "should_release=true" >> $GITHUB_OUTPUT
            fi
          fi

      # Publishing Phase (only runs if should_release == true)
      - name: Update package.json version
        if: steps.check_tag.outputs.should_release == 'true'
        run: |
          NEXT_VERSION="${{ steps.next_version.outputs.next_version }}"
          npm version $NEXT_VERSION --no-git-tag-version --no-commit-hooks

      - name: Publish to npm
        if: steps.check_tag.outputs.should_release == 'true'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          NEXT_VERSION="${{ steps.next_version.outputs.next_version }}"
          echo "Publishing version $NEXT_VERSION to npm..."
          npm whoami
          if npm publish --access public; then
            echo "Successfully published $NEXT_VERSION to npm"
          else
            echo "Failed to publish to npm"
            exit 1
          fi

      - name: Verify npm publication
        if: steps.check_tag.outputs.should_release == 'true'
        run: |
          NEXT_VERSION="${{ steps.next_version.outputs.next_version }}"
          PACKAGE_NAME="@nazariistrohush/gql-prisma-select"

          echo "Verifying package $PACKAGE_NAME@$NEXT_VERSION was published..."
          
          # Loop to check for availability with retries
          MAX_RETRIES=12
          count=0
          success=false
          
          while [ $count -lt $MAX_RETRIES ]; do
            if npm view "$PACKAGE_NAME@$NEXT_VERSION" version > /dev/null 2>&1; then
            echo "✅ Package $PACKAGE_NAME@$NEXT_VERSION successfully verified on npm"
              success=true
              break
            fi
            
            count=$((count + 1))
            echo "Attempt $count/$MAX_RETRIES: Package not found yet, waiting 10 seconds..."
            sleep 10
          done
          
          if [ "$success" = false ]; then
             echo "⚠️ Warning: Could not verify package on npm registry after 2 minutes."
             echo "This might be due to replication lag. Proceeding with release creation anyway."
             # Do not fail the workflow here, as publish step succeeded
          fi

      - name: Create and push tag
        if: steps.check_tag.outputs.should_release == 'true'
        run: |
          NEXT_VERSION="${{ steps.next_version.outputs.next_version }}"
          TAG="$NEXT_VERSION"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Creating tag: $TAG for version: $NEXT_VERSION"
          git tag -a "$TAG" -m "Release $NEXT_VERSION"

          echo "Pushing tag to origin..."
          git push origin "$TAG"

          echo "Successfully created and pushed tag: $TAG"

      - name: Create GitHub Release
        if: steps.check_tag.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.next_version.outputs.next_version }}
          name: Release ${{ steps.next_version.outputs.next_version }}
          body: |
            ## Changes in this Release

            ### Installation

            ```bash
            npm install @nazariistrohush/gql-prisma-select@${{ steps.next_version.outputs.next_version }}
            ```
          draft: false
          prerelease: false

